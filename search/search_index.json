{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A Fast and Easy to use microframework for the web. Description Crow is a C++ microframework for running web services. It uses routing similar to Python's Flask which makes it easy to use. It is also extremely fast, beating multiple existing C++ frameworks as well as non C++ frameworks. Features Easy Routing (similar to flask). Type-safe Handlers. Blazingly fast (see this benchmark and this benchmark ). Built in JSON support. Mustache based templating library ( crow::mustache ). Header only library (single header file available). Middleware support for extensions. HTTP/1.1 and Websocket support. Multi-part request and response support. Uses modern C++ (11/14) Still in development HTTP/2 support Documentation Available here . Examples Hello World #define CROW_MAIN #include \"crow.h\" int main () { crow :: SimpleApp app ; CROW_ROUTE ( app , \"/\" )([](){ return \"Hello world\" ; }); app . port ( 18080 ). multithreaded (). run (); } JSON Response CROW_ROUTE ( app , \"/json\" ) ([]{ crow :: json :: wvalue x ; x [ \"message\" ] = \"Hello, World!\" ; return x ; }); Arguments CROW_ROUTE ( app , \"/hello/<int>\" ) ([]( int count ){ if ( count > 100 ) return crow :: response ( 400 ); std :: ostringstream os ; os << count << \" bottles of beer!\" ; return crow :: response ( os . str ()); }); Handler arguments type check at compile time // Compile error with message \"Handler type is mismatched with URL paramters\" CROW_ROUTE ( app , \"/another/<int>\" ) ([]( int a , int b ){ return crow :: response ( 500 ); }); Handling JSON Requests CROW_ROUTE ( app , \"/add_json\" ) . methods ( \"POST\" _method ) ([]( const crow :: request & req ){ auto x = crow :: json :: load ( req . body ); if ( ! x ) return crow :: response ( 400 ); int sum = x [ \"a\" ]. i () + x [ \"b\" ]. i (); std :: ostringstream os ; os << sum ; return crow :: response { os . str ()}; }); More examples can be found here . Setting Up / Building Available here . Disclaimer CrowCpp/Crow is a project based on ipkn/crow. Neither CrowCpp, it's members, or this projects have been associated with, or endorsed or supported by ipkn (Jaeseung Ha) in any way. We do use ipkn/crow's source code under the BSD-3 clause license and sometimes refer to the public comments available on the github repository. But we do not in any way claim to be associated with or in contact with ipkn (Jaeseung Ha) regarding CrowCpp or CrowCpp/Crow","title":"Home"},{"location":"#_1","text":"","title":""},{"location":"#description","text":"Crow is a C++ microframework for running web services. It uses routing similar to Python's Flask which makes it easy to use. It is also extremely fast, beating multiple existing C++ frameworks as well as non C++ frameworks.","title":"Description"},{"location":"#features","text":"Easy Routing (similar to flask). Type-safe Handlers. Blazingly fast (see this benchmark and this benchmark ). Built in JSON support. Mustache based templating library ( crow::mustache ). Header only library (single header file available). Middleware support for extensions. HTTP/1.1 and Websocket support. Multi-part request and response support. Uses modern C++ (11/14)","title":"Features"},{"location":"#still-in-development","text":"HTTP/2 support","title":"Still in development"},{"location":"#documentation","text":"Available here .","title":"Documentation"},{"location":"#examples","text":"","title":"Examples"},{"location":"#hello-world","text":"#define CROW_MAIN #include \"crow.h\" int main () { crow :: SimpleApp app ; CROW_ROUTE ( app , \"/\" )([](){ return \"Hello world\" ; }); app . port ( 18080 ). multithreaded (). run (); }","title":"Hello World"},{"location":"#json-response","text":"CROW_ROUTE ( app , \"/json\" ) ([]{ crow :: json :: wvalue x ; x [ \"message\" ] = \"Hello, World!\" ; return x ; });","title":"JSON Response"},{"location":"#arguments","text":"CROW_ROUTE ( app , \"/hello/<int>\" ) ([]( int count ){ if ( count > 100 ) return crow :: response ( 400 ); std :: ostringstream os ; os << count << \" bottles of beer!\" ; return crow :: response ( os . str ()); }); Handler arguments type check at compile time // Compile error with message \"Handler type is mismatched with URL paramters\" CROW_ROUTE ( app , \"/another/<int>\" ) ([]( int a , int b ){ return crow :: response ( 500 ); });","title":"Arguments"},{"location":"#handling-json-requests","text":"CROW_ROUTE ( app , \"/add_json\" ) . methods ( \"POST\" _method ) ([]( const crow :: request & req ){ auto x = crow :: json :: load ( req . body ); if ( ! x ) return crow :: response ( 400 ); int sum = x [ \"a\" ]. i () + x [ \"b\" ]. i (); std :: ostringstream os ; os << sum ; return crow :: response { os . str ()}; }); More examples can be found here .","title":"Handling JSON Requests"},{"location":"#setting-up-building","text":"Available here .","title":"Setting Up / Building"},{"location":"#disclaimer","text":"CrowCpp/Crow is a project based on ipkn/crow. Neither CrowCpp, it's members, or this projects have been associated with, or endorsed or supported by ipkn (Jaeseung Ha) in any way. We do use ipkn/crow's source code under the BSD-3 clause license and sometimes refer to the public comments available on the github repository. But we do not in any way claim to be associated with or in contact with ipkn (Jaeseung Ha) regarding CrowCpp or CrowCpp/Crow","title":"Disclaimer"},{"location":"getting_started/setup/","text":"This page explains how to set Crow up for use with your project. Requirements C++ compiler with C++14 support. Crow's CI uses g++-9.3 and clang-7.0 running on AMD64 (x86_64) and ARM64v8 boost library (1.70 or later). (optional) ZLib for HTTP Compression. (optional) CMake and Python3 to build tests and/or examples. (optional) Linking with jemalloc/tcmalloc is recommended for speed. Note While using Boost 1.70 or later is recommended, it may be possible to compile a Crow application with version 1.64 Installing Requirements Note The Linux requirements are for developing and compiling a Crow application. Running a built application requires the actual libraries rather than just the development headers. Ubuntu sudo apt-get install build-essential libboost-all-dev Non Debian based GNU/Linux Use your package manager to install the following: - GCC and G++ (or Clang and Clang++) - Boost Development headers (sometimes part of the Boost package itself) OSX brew install boost Windows Microsoft Visual Studio 2019 (older versions not tested) Downloading Either run git clone https://github.com/crowcpp/crow.git or download crow_all.h from the releases section. You can also download a zip of the project on github. Includes folder Copy the /includes folder to your project's root folder. Add #include \"path/to/includes/crow.h\" to your .cpp file. For any middlewares, add #include \"path/to/includes/middlewares/some_middleware.h\" . Single header file If you've downloaded crow_all.h , you can skip to step 4 . Make sure you have python 3 installed. Open a terminal (or cmd.exe ) instance in /path/to/crow/scripts . Run python merge_all.py ../include crow_all.h (replace / with \\ if you're on Windows). Copy the crow_all.h file to where you put your libraries (if you don't know where this is, you can put it anywhere). Add #include \"path/to/crow_all.h\" to your .cpp file. Note : All middlewares are included with the merged header file, if you would like to include or exclude middlewares use the -e or -i arguments. building via CLI To build a crow Project, do the following: GCC (G++) Release: g++ main.cpp -lpthread -lboost_system . Debug: g++ main.cpp -ggdb -lpthread -lboost_system -DCROW_ENABLE_DEBUG . SSL: g++ main.cpp -lssl -lcrypto -lpthread -lboost_system -DCROW_ENABLE_SSL . Clang Release: clang++ main.cpp -lpthread -lboost_system . Debug: clang++ main.cpp -g -lpthread -lboost_system -DCROW_ENABLE_DEBUG . SSL: clang++ main.cpp -lssl -lcrypto -lpthread -lboost_system -DCROW_ENABLE_SSL . Microsoft Visual Studio 2019 The following guide will use example_with_all.cpp as the Crow application for demonstration purposes. Generate crow_all.h following Single header file . git clone https://github.com/microsoft/vcpkg.git .\\vcpkg\\bootstrap-vcpkg.bat .\\vcpkg\\vcpkg integrate install Create empty Visual Studio project. In solution explorer, right click the name of your project then click Open Folder in File Explorer . Copy crow_all.h , example_with_all.cpp , vcpkg.json to opened folder. Add crow_all.h to Header Files and example_with_all.cpp to Source Files . In solution explorer, right click the name of your project then click Properties . Under vcpkg , set Use Vcpkg Manifest to Yes and Additional Options to --feature-flags=\"versions\" . Set Debug/Release and x64/x86 . Run. building via CMake Add the following to your CMakeLists.txt : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 find_package ( Threads ) find_package ( ZLIB ) find_package ( OpenSSL ) if ( OPENSSL_FOUND ) include_directories ( ${ OPENSSL_INCLUDE_DIR } ) endif () if ( NOT CMAKE_BUILD_TYPE ) message ( STATUS \"No build type selected, default to Release\" ) set ( CMAKE_BUILD_TYPE \"Release\" ) endif () if ( MSVC ) set ( Boost_USE_STATIC_LIBS \"On\" ) find_package ( Boost 1.70 COMPONENTS system thread regex REQUIRED ) else () find_package ( Boost 1.70 COMPONENTS system thread REQUIRED ) endif () include_directories ( ${ Boost_INCLUDE_DIR } ) set ( PROJECT_INCLUDE_DIR ${ PROJECT_SOURCE_DIR } /include ) include_directories ( \"${PROJECT_INCLUDE_DIR}\" ) Note The last 2 lines are unnecessary if you're using crow_all.h . Building Crow tests and examples Out-of-source build with CMake is recommended. mkdir build cd build cmake .. make Running Cmake will create crow_all.h file and place it in the build directory. You can run tests with following command: ctest -V Installing Crow if you wish to use Crow globally without copying crow_all.h in your projects, you can install Crow on your machine with the procedure below. mkdir build cd build cmake .. make install make install will copy crow_all.h automatically in your /usr/local/include thus making it available globally for use.","title":"Setup"},{"location":"getting_started/setup/#requirements","text":"C++ compiler with C++14 support. Crow's CI uses g++-9.3 and clang-7.0 running on AMD64 (x86_64) and ARM64v8 boost library (1.70 or later). (optional) ZLib for HTTP Compression. (optional) CMake and Python3 to build tests and/or examples. (optional) Linking with jemalloc/tcmalloc is recommended for speed. Note While using Boost 1.70 or later is recommended, it may be possible to compile a Crow application with version 1.64","title":"Requirements"},{"location":"getting_started/setup/#installing-requirements","text":"Note The Linux requirements are for developing and compiling a Crow application. Running a built application requires the actual libraries rather than just the development headers.","title":"Installing Requirements"},{"location":"getting_started/setup/#ubuntu","text":"sudo apt-get install build-essential libboost-all-dev","title":"Ubuntu"},{"location":"getting_started/setup/#non-debian-based-gnulinux","text":"Use your package manager to install the following: - GCC and G++ (or Clang and Clang++) - Boost Development headers (sometimes part of the Boost package itself)","title":"Non Debian based GNU/Linux"},{"location":"getting_started/setup/#osx","text":"brew install boost","title":"OSX"},{"location":"getting_started/setup/#windows","text":"Microsoft Visual Studio 2019 (older versions not tested)","title":"Windows"},{"location":"getting_started/setup/#downloading","text":"Either run git clone https://github.com/crowcpp/crow.git or download crow_all.h from the releases section. You can also download a zip of the project on github.","title":"Downloading"},{"location":"getting_started/setup/#includes-folder","text":"Copy the /includes folder to your project's root folder. Add #include \"path/to/includes/crow.h\" to your .cpp file. For any middlewares, add #include \"path/to/includes/middlewares/some_middleware.h\" .","title":"Includes folder"},{"location":"getting_started/setup/#single-header-file","text":"If you've downloaded crow_all.h , you can skip to step 4 . Make sure you have python 3 installed. Open a terminal (or cmd.exe ) instance in /path/to/crow/scripts . Run python merge_all.py ../include crow_all.h (replace / with \\ if you're on Windows). Copy the crow_all.h file to where you put your libraries (if you don't know where this is, you can put it anywhere). Add #include \"path/to/crow_all.h\" to your .cpp file. Note : All middlewares are included with the merged header file, if you would like to include or exclude middlewares use the -e or -i arguments.","title":"Single header file"},{"location":"getting_started/setup/#building-via-cli","text":"To build a crow Project, do the following:","title":"building via CLI"},{"location":"getting_started/setup/#gcc-g","text":"Release: g++ main.cpp -lpthread -lboost_system . Debug: g++ main.cpp -ggdb -lpthread -lboost_system -DCROW_ENABLE_DEBUG . SSL: g++ main.cpp -lssl -lcrypto -lpthread -lboost_system -DCROW_ENABLE_SSL .","title":"GCC (G++)"},{"location":"getting_started/setup/#clang","text":"Release: clang++ main.cpp -lpthread -lboost_system . Debug: clang++ main.cpp -g -lpthread -lboost_system -DCROW_ENABLE_DEBUG . SSL: clang++ main.cpp -lssl -lcrypto -lpthread -lboost_system -DCROW_ENABLE_SSL .","title":"Clang"},{"location":"getting_started/setup/#microsoft-visual-studio-2019","text":"The following guide will use example_with_all.cpp as the Crow application for demonstration purposes. Generate crow_all.h following Single header file . git clone https://github.com/microsoft/vcpkg.git .\\vcpkg\\bootstrap-vcpkg.bat .\\vcpkg\\vcpkg integrate install Create empty Visual Studio project. In solution explorer, right click the name of your project then click Open Folder in File Explorer . Copy crow_all.h , example_with_all.cpp , vcpkg.json to opened folder. Add crow_all.h to Header Files and example_with_all.cpp to Source Files . In solution explorer, right click the name of your project then click Properties . Under vcpkg , set Use Vcpkg Manifest to Yes and Additional Options to --feature-flags=\"versions\" . Set Debug/Release and x64/x86 . Run.","title":"Microsoft Visual Studio 2019"},{"location":"getting_started/setup/#building-via-cmake","text":"Add the following to your CMakeLists.txt : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 find_package ( Threads ) find_package ( ZLIB ) find_package ( OpenSSL ) if ( OPENSSL_FOUND ) include_directories ( ${ OPENSSL_INCLUDE_DIR } ) endif () if ( NOT CMAKE_BUILD_TYPE ) message ( STATUS \"No build type selected, default to Release\" ) set ( CMAKE_BUILD_TYPE \"Release\" ) endif () if ( MSVC ) set ( Boost_USE_STATIC_LIBS \"On\" ) find_package ( Boost 1.70 COMPONENTS system thread regex REQUIRED ) else () find_package ( Boost 1.70 COMPONENTS system thread REQUIRED ) endif () include_directories ( ${ Boost_INCLUDE_DIR } ) set ( PROJECT_INCLUDE_DIR ${ PROJECT_SOURCE_DIR } /include ) include_directories ( \"${PROJECT_INCLUDE_DIR}\" ) Note The last 2 lines are unnecessary if you're using crow_all.h .","title":"building via CMake"},{"location":"getting_started/setup/#building-crow-tests-and-examples","text":"Out-of-source build with CMake is recommended. mkdir build cd build cmake .. make Running Cmake will create crow_all.h file and place it in the build directory. You can run tests with following command: ctest -V","title":"Building Crow tests and examples"},{"location":"getting_started/setup/#installing-crow","text":"if you wish to use Crow globally without copying crow_all.h in your projects, you can install Crow on your machine with the procedure below. mkdir build cd build cmake .. make install make install will copy crow_all.h automatically in your /usr/local/include thus making it available globally for use.","title":"Installing Crow"},{"location":"getting_started/your_first_application/","text":"This page shows how you can get started with a simple hello world application. 1. Include Starting with an empty main.cpp file, first add #define CROW_MAIN then #include \"crow.h\" or #include \"crow_all.h\" if you're using the single header file. Note If you're using multiple C++ source files make sure to have CROW_MAIN defined only in your main source file. 2. App declaration Next Create a main() and declare a crow :: SimpleApp inside, your code should look like this int main () { crow :: SimpleApp app ; } The App (or SimpleApp) class organizes all the different parts of Crow and provides the developer (you) a simple interface to interact with these parts. For more information, please go here . 3. Adding routes Once you have your app, the next step is to add routes (or endpoints). You can do so with the CROW_ROUTE macro. CROW_ROUTE ( app , \"/\" )([](){ return \"Hello world\" ; }); For more details on routes, please go here . 4. Running the app Once you're happy with how you defined all your routes, you're going to want to instruct Crow to run your app. This is done using the run() method. app . port ( 18080 ). multithreaded (). run (); Please note that the port() and multithreaded() methods aren't needed, Though not using port() will cause the default port ( 80 ) to be used. Putting it all together Once you've followed all the steps above, your code should look similar to this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #define CROW_MAIN //let the compiler know this is your main cpp file #include \"crow.h\" //#include \"crow_all.h\" int main () { crow :: SimpleApp app ; //define your crow application //define your endpoint at the root directory CROW_ROUTE ( app , \"/\" )([](){ return \"Hello world\" ; }); //set the port, set the app to run on multiple threads, and run the app app . port ( 18080 ). multithreaded (). run (); } After building and running your .cpp file, you should be able to access your endpoint at http://localhost:18080 . Opening this URL in your browser will show a white screen with \"Hello world\" typed on it.","title":"Your First Application"},{"location":"getting_started/your_first_application/#1-include","text":"Starting with an empty main.cpp file, first add #define CROW_MAIN then #include \"crow.h\" or #include \"crow_all.h\" if you're using the single header file. Note If you're using multiple C++ source files make sure to have CROW_MAIN defined only in your main source file.","title":"1. Include"},{"location":"getting_started/your_first_application/#2-app-declaration","text":"Next Create a main() and declare a crow :: SimpleApp inside, your code should look like this int main () { crow :: SimpleApp app ; } The App (or SimpleApp) class organizes all the different parts of Crow and provides the developer (you) a simple interface to interact with these parts. For more information, please go here .","title":"2. App declaration"},{"location":"getting_started/your_first_application/#3-adding-routes","text":"Once you have your app, the next step is to add routes (or endpoints). You can do so with the CROW_ROUTE macro. CROW_ROUTE ( app , \"/\" )([](){ return \"Hello world\" ; }); For more details on routes, please go here .","title":"3. Adding routes"},{"location":"getting_started/your_first_application/#4-running-the-app","text":"Once you're happy with how you defined all your routes, you're going to want to instruct Crow to run your app. This is done using the run() method. app . port ( 18080 ). multithreaded (). run (); Please note that the port() and multithreaded() methods aren't needed, Though not using port() will cause the default port ( 80 ) to be used.","title":"4. Running the app"},{"location":"getting_started/your_first_application/#putting-it-all-together","text":"Once you've followed all the steps above, your code should look similar to this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #define CROW_MAIN //let the compiler know this is your main cpp file #include \"crow.h\" //#include \"crow_all.h\" int main () { crow :: SimpleApp app ; //define your crow application //define your endpoint at the root directory CROW_ROUTE ( app , \"/\" )([](){ return \"Hello world\" ; }); //set the port, set the app to run on multiple threads, and run the app app . port ( 18080 ). multithreaded (). run (); } After building and running your .cpp file, you should be able to access your endpoint at http://localhost:18080 . Opening this URL in your browser will show a white screen with \"Hello world\" typed on it.","title":"Putting it all together"},{"location":"guides/app/","text":"A Crow app defines an interface to allow the developer access to all the different parts of the framework, without having to manually deal with each one. An app allows access to the http server (for handling connections), router (for handling URLs and requests), Middlewares (for extending Crow), amoung many others. Crow has 2 different app types: SimpleApp Has no middlewares. App<m1, m2, ...> Has middlewares. Using the app To use a Crow app, simply define crow :: SimpleApp or crow :: App < m1 , m2 ... > if you're using middlewares. The methods of an app can be chained. That means that you can configure and run your app in the same code line. app . bindaddr ( 192.168.1.2 ). port ( 443 ). ssl_file ( \"certfile.crt\" , \"keyfile.key\" ). multithreaded (). run (); Or if you like your code neat app . bindaddr ( 192.168.1.2 ) . port ( 443 ) . ssl_file ( \"certfile.crt\" , \"keyfile.key\" ) . multithreaded () . run (); For more info on middlewares, check out this page . For more info on what functions are available to a Crow app, go here .","title":"App"},{"location":"guides/app/#simpleapp","text":"Has no middlewares.","title":"SimpleApp"},{"location":"guides/app/#appm1-m2","text":"Has middlewares.","title":"App&lt;m1, m2, ...&gt;"},{"location":"guides/app/#using-the-app","text":"To use a Crow app, simply define crow :: SimpleApp or crow :: App < m1 , m2 ... > if you're using middlewares. The methods of an app can be chained. That means that you can configure and run your app in the same code line. app . bindaddr ( 192.168.1.2 ). port ( 443 ). ssl_file ( \"certfile.crt\" , \"keyfile.key\" ). multithreaded (). run (); Or if you like your code neat app . bindaddr ( 192.168.1.2 ) . port ( 443 ) . ssl_file ( \"certfile.crt\" , \"keyfile.key\" ) . multithreaded () . run (); For more info on middlewares, check out this page . For more info on what functions are available to a Crow app, go here .","title":"Using the app"},{"location":"guides/compression/","text":"Crow supports Zlib compression using Gzip or Deflate algorithms. HTTP Compression HTTP compression is by default disabled in crow. Do the following to enable it: 1. Add #define CROW_ENABLE_COMPRESSION to the top of your main source file. 2. Call use_compression ( crow :: compression :: algorithm ) on your crow app. 3. When compiling your application, make sure that ZLIB is included as a dependency. Either through -lz argument or find_package(ZLIB) in CMake. Note step 3 is not needed for MSVC since vcpckg.json already includes zlib as a dependency by default For the compression algorim you can use crow::compression::algorithm::DEFLATE or crow::compression::algorithm::GZIP . And now your HTTP responses will be compressed. Websocket Compression Crow currently does not support Websocket compression. Feel free to discuss the subject with us on Github if you're feeling adventurous and want to try to implement it. We appreciate all the help.","title":"Compression"},{"location":"guides/compression/#http-compression","text":"HTTP compression is by default disabled in crow. Do the following to enable it: 1. Add #define CROW_ENABLE_COMPRESSION to the top of your main source file. 2. Call use_compression ( crow :: compression :: algorithm ) on your crow app. 3. When compiling your application, make sure that ZLIB is included as a dependency. Either through -lz argument or find_package(ZLIB) in CMake. Note step 3 is not needed for MSVC since vcpckg.json already includes zlib as a dependency by default For the compression algorim you can use crow::compression::algorithm::DEFLATE or crow::compression::algorithm::GZIP . And now your HTTP responses will be compressed.","title":"HTTP Compression"},{"location":"guides/compression/#websocket-compression","text":"Crow currently does not support Websocket compression. Feel free to discuss the subject with us on Github if you're feeling adventurous and want to try to implement it. We appreciate all the help.","title":"Websocket Compression"},{"location":"guides/json/","text":"Crow has built in support for JSON data. type The types of values that rvalue and wvalue can take are as follows: False : from type bool . True : from type bool . Number Floating_point : from type double . Signed_integer : from type int . Unsigned_integer : from type unsigned int . String : from type std::string . List : from type std::vector . Object : from type crow::json::wvalue or crow::json::rvalue . This last type means that rvalue or wvalue can have keys. rvalue JSON read value, used for taking a JSON string and parsing it into crow::json . You can read individual items of the rvalue, but you cannot add items to it. To do that, you need to convert it to a wvalue , which can be done by simply writing crow :: json :: wvalue wval ( rval ); (assuming rval is your rvalue ). For more info on read values go here . wvalue JSON write value, used for creating, editing and converting JSON to a string. Note setting a wvalue to object type can be done by simply assigning a value to whatever string key you like, something like wval [ \"key1\" ] = val1 ; . Keep in mind that val1 can be any of the above types. A wvalue can be treated as an object or even a list (setting a value by using json[3] = 32 for example). Please note that this will remove the data in the value if it isn't of List type. An object type wvalue uses std::unordered_map by default, if you want to have your returned wvalue key value pairs be sorted (using std::map ) you can add #define CROW_JSON_USE_MAP to the top of your program. A JSON wvalue can be returned directly inside a route handler, this will cause the content-type header to automatically be set to Application/json and the JSON value will be converted to string and placed in the response body. For more information go to Routes . For more info on write values go here . Note Crow's json exceptions can be disabled by using the #define CROW_JSON_NO_ERROR_CHECK macro. This should increase the program speed with the drawback of having unexpected behavious when used incorrectly (e.g. by attempting to parse an invalid json object).","title":"JSON"},{"location":"guides/json/#type","text":"The types of values that rvalue and wvalue can take are as follows: False : from type bool . True : from type bool . Number Floating_point : from type double . Signed_integer : from type int . Unsigned_integer : from type unsigned int . String : from type std::string . List : from type std::vector . Object : from type crow::json::wvalue or crow::json::rvalue . This last type means that rvalue or wvalue can have keys.","title":"type"},{"location":"guides/json/#rvalue","text":"JSON read value, used for taking a JSON string and parsing it into crow::json . You can read individual items of the rvalue, but you cannot add items to it. To do that, you need to convert it to a wvalue , which can be done by simply writing crow :: json :: wvalue wval ( rval ); (assuming rval is your rvalue ). For more info on read values go here .","title":"rvalue"},{"location":"guides/json/#wvalue","text":"JSON write value, used for creating, editing and converting JSON to a string. Note setting a wvalue to object type can be done by simply assigning a value to whatever string key you like, something like wval [ \"key1\" ] = val1 ; . Keep in mind that val1 can be any of the above types. A wvalue can be treated as an object or even a list (setting a value by using json[3] = 32 for example). Please note that this will remove the data in the value if it isn't of List type. An object type wvalue uses std::unordered_map by default, if you want to have your returned wvalue key value pairs be sorted (using std::map ) you can add #define CROW_JSON_USE_MAP to the top of your program. A JSON wvalue can be returned directly inside a route handler, this will cause the content-type header to automatically be set to Application/json and the JSON value will be converted to string and placed in the response body. For more information go to Routes . For more info on write values go here . Note Crow's json exceptions can be disabled by using the #define CROW_JSON_NO_ERROR_CHECK macro. This should increase the program speed with the drawback of having unexpected behavious when used incorrectly (e.g. by attempting to parse an invalid json object).","title":"wvalue"},{"location":"guides/logging/","text":"Crow comes with a simple and easy to use logging system. Setting up logging level You can set up the level at which crow displays logs by using the app's loglevel(crow::LogLevel) method. The available log levels are as follows (please not that setting a level will also display all logs below this level): Debug Info Warning Error Critical To set a logLevel, just use app . loglevel ( crow :: LogLevel :: Warning ) , This will not show any debug or info logs. It will however still show error and critical logs. Please note that setting the Macro CROW_ENABLE_DEBUG during compilation will also set the log level to Debug . Writing a log Writing a log is as simple as CROW_LOG_ < LOG LEVEL > << \"Hello\" ; (replace<LOG LEVEL> with the actual level in all caps, so you have CROW_LOG_WARNING ).","title":"Logging"},{"location":"guides/logging/#setting-up-logging-level","text":"You can set up the level at which crow displays logs by using the app's loglevel(crow::LogLevel) method. The available log levels are as follows (please not that setting a level will also display all logs below this level): Debug Info Warning Error Critical To set a logLevel, just use app . loglevel ( crow :: LogLevel :: Warning ) , This will not show any debug or info logs. It will however still show error and critical logs. Please note that setting the Macro CROW_ENABLE_DEBUG during compilation will also set the log level to Debug .","title":"Setting up logging level"},{"location":"guides/logging/#writing-a-log","text":"Writing a log is as simple as CROW_LOG_ < LOG LEVEL > << \"Hello\" ; (replace<LOG LEVEL> with the actual level in all caps, so you have CROW_LOG_WARNING ).","title":"Writing a log"},{"location":"guides/middleware/","text":"Any middleware requires following 3 members: struct context Storing data for the middleware; can be read from another middleware or handlers before_handle Called before handling the request. If res.end() is called, the operation is halted. ( after_handle will still be called) 2 signatures: void before_handle ( request & req , response & res , context & ctx ) if you only need to access this middleware's context. template < typename AllContext > void before_handle ( request & req , response & res , context & ctx , AllContext & all_ctx ) You can access other middlewares' context by calling all_ctx . template get < MW > () ctx == all_ctx . template get < CurrentMiddleware > () after_handle Called after handling the request. void after_handle ( request & req , response & res , context & ctx ) template < typename AllContext > void after_handle ( request & req , response & res , context & ctx , AllContext & all_ctx ) This was pulled from cookie_parser.h . Further Editing required, possibly use parts of @ipkn's wiki page .","title":"Middleware"},{"location":"guides/middleware/#struct-context","text":"Storing data for the middleware; can be read from another middleware or handlers","title":"struct context"},{"location":"guides/middleware/#before_handle","text":"Called before handling the request. If res.end() is called, the operation is halted. ( after_handle will still be called) 2 signatures: void before_handle ( request & req , response & res , context & ctx ) if you only need to access this middleware's context. template < typename AllContext > void before_handle ( request & req , response & res , context & ctx , AllContext & all_ctx ) You can access other middlewares' context by calling all_ctx . template get < MW > () ctx == all_ctx . template get < CurrentMiddleware > ()","title":"before_handle"},{"location":"guides/middleware/#after_handle","text":"Called after handling the request. void after_handle ( request & req , response & res , context & ctx ) template < typename AllContext > void after_handle ( request & req , response & res , context & ctx , AllContext & all_ctx ) This was pulled from cookie_parser.h . Further Editing required, possibly use parts of @ipkn's wiki page .","title":"after_handle"},{"location":"guides/multipart/","text":"Multipart is a way of forming HTTP requests or responses to contain multiple distinct parts. Such an approach allows a request to contain multiple different pieces of data with potentially conflicting data types in a single response payload. It is typically used either in html forms, or when uploading multiple files. The structure of a multipart request is typically consistent of: A Header: Typically multipart/form-data;boundary=<boundary> , This defines the HTTP message as being multipart, as well as defining the separator used to distinguish the different parts. 1 or more parts: --<boundary> Part header: typically content-disposition: mime/type; name=\"<fieldname>\" ( mime/type should be replaced with the actual mime-type), can also contain a filename property (separated from the rest by a ; and structured similarly to the name property) Value --<boundary>-- Crow supports multipart requests and responses though crow::multipart::message . A message can be created either by defining the headers, boundary, and individual parts and using them to create the message. or simply by reading a crow::request . Once a multipart message has been made, the individual parts can be accessed throught mpmes.parts , parts is an std::vector , so accessing the individual parts should be straightforward. In order to access the individual part's name or filename, something like mpmes . parts [ 0 ]. headers [ 0 ]. params [ \"name\" ] sould do the trick. For more info on Multipart messages, go here","title":"Multipart"},{"location":"guides/proxies/","text":"You can set Crow up behind any HTTP proxy of your liking, but we will be focusing specifically on 2 of the most popular web server software solutions, Apache2 and Nginx. A reverse proxy allows you to use Crow without exposing it directly to the internet. It also allows you to, for example, have crow run on a certain specific domain name, subdomain, or even a path, such as domain.abc/crow . We advise that you set crow up behind some form of reverse proxy if you plan on running a production Crow server that isn't local. SSL When using a proxy, make sure that you do not compile Crow with SSL enabled. SSL should be handled by the proxy. Apache2 Assuming you have both Apache2 and the modules proxy , proxy_http , proxy_html (if you plan on serving html pages), and proxy_wstunnel (if you plan on using websockets). You will need to enable those modules, which you can do using the following commands: a2enmod proxy a2enmod proxy_http a2enmod proxy_html a2enmod proxy_wstunnel Next up you'll need to change your configuration (default is /etc/apache2/sites-enabled/000-default.conf ) and add the following lines (replace localhost and 40080 with the address and port you defined for your Crow App): ProxyPass / http://localhost:40080 ProxyPassReverse / http://localhost:40080 If you want crow to run in a subdirectory (such as domain.abc/crow ) you can use the location tag: <Location \"/crow\"> ProxyPass http://localhost:40080 ProxyPassReverse http://localhost:40080 </Location> Note If you're using an Arch Linux based OS. You will have to access /etc/httpd/conf/httpd.conf to enable modules and change configuration. Nginx Setting Nginx up is slightly simpler than Apache, all you need is the Nginx package itself. Once you've installed it, go to the configuration file (usually a .conf file located in /etc/nginx ) and add the following lines to your server section (replace localhost and 40080 with the address and port you defined for your Crow App): location / { proxy_pass http://localhost:40080/; proxy_http_version 1.1; } Remember to remove or comment out any existing location / section. Alternatively, if you want to use a subdirectory, you can simply change the location parameter as such: location /crow/ { proxy_pass http://localhost:40080/; proxy_http_version 1.1; }","title":"Proxies"},{"location":"guides/proxies/#apache2","text":"Assuming you have both Apache2 and the modules proxy , proxy_http , proxy_html (if you plan on serving html pages), and proxy_wstunnel (if you plan on using websockets). You will need to enable those modules, which you can do using the following commands: a2enmod proxy a2enmod proxy_http a2enmod proxy_html a2enmod proxy_wstunnel Next up you'll need to change your configuration (default is /etc/apache2/sites-enabled/000-default.conf ) and add the following lines (replace localhost and 40080 with the address and port you defined for your Crow App): ProxyPass / http://localhost:40080 ProxyPassReverse / http://localhost:40080 If you want crow to run in a subdirectory (such as domain.abc/crow ) you can use the location tag: <Location \"/crow\"> ProxyPass http://localhost:40080 ProxyPassReverse http://localhost:40080 </Location> Note If you're using an Arch Linux based OS. You will have to access /etc/httpd/conf/httpd.conf to enable modules and change configuration.","title":"Apache2"},{"location":"guides/proxies/#nginx","text":"Setting Nginx up is slightly simpler than Apache, all you need is the Nginx package itself. Once you've installed it, go to the configuration file (usually a .conf file located in /etc/nginx ) and add the following lines to your server section (replace localhost and 40080 with the address and port you defined for your Crow App): location / { proxy_pass http://localhost:40080/; proxy_http_version 1.1; } Remember to remove or comment out any existing location / section. Alternatively, if you want to use a subdirectory, you can simply change the location parameter as such: location /crow/ { proxy_pass http://localhost:40080/; proxy_http_version 1.1; }","title":"Nginx"},{"location":"guides/query-string/","text":"A query string is the part of the url that comes after a ? character, it is usually formatted as key=value&otherkey=othervalue . Crow supports query strings through crow::request::url_params . The object is of type crow::query_string and can has the following functions: get(name) Returns the value (as char*) based on the given key (or name). Returns nullptr if the key is not found. pop(name) Works the same as get , but removes the returned value. Note crow::request::url_params is a const value, therefore for pop (also pop_list and pop_dict) to work, a copy needs to be made. get_list(name) A url can be http://example.com?key[]=value1&key[]=value2&key[]=value3 . Using get_list(\"key\") on such a url returns an std::vector<std::string> containing [value1, value2, value3] . get_list ( \"key\" , false ) can be used to parse http://example.com?key=value1&key=value2&key=value3 pop_list(name) Works the same as get_list but removes all instances of values having the given key ( use_brackets is also available here). get_dict(name) Returns an std::unordered_map<std::string, std::string> from a query string such as ?key[sub_key1]=value1&key[sub_key2]=value2&key[sub_key3]=value3 . The key in the map is what's in the brackets ( sub_key1 for example), and the value being what's after the = sign ( value1 ). The name passed to the function is not part of the returned value. pop_dict(name) Works the same as get_dict but removing the values from the query string. Warning if your query string contains both a list and dictionary with the same key, it is best to use pop_list before either get_dict or pop_dict , since a map cannot contain more than one value per key, each item in the list will override the previous and only the last will remain with an empty key. For more information take a look here .","title":"Query Strings"},{"location":"guides/query-string/#getname","text":"Returns the value (as char*) based on the given key (or name). Returns nullptr if the key is not found.","title":"get(name)"},{"location":"guides/query-string/#popname","text":"Works the same as get , but removes the returned value. Note crow::request::url_params is a const value, therefore for pop (also pop_list and pop_dict) to work, a copy needs to be made.","title":"pop(name)"},{"location":"guides/query-string/#get_listname","text":"A url can be http://example.com?key[]=value1&key[]=value2&key[]=value3 . Using get_list(\"key\") on such a url returns an std::vector<std::string> containing [value1, value2, value3] . get_list ( \"key\" , false ) can be used to parse http://example.com?key=value1&key=value2&key=value3","title":"get_list(name)"},{"location":"guides/query-string/#pop_listname","text":"Works the same as get_list but removes all instances of values having the given key ( use_brackets is also available here).","title":"pop_list(name)"},{"location":"guides/query-string/#get_dictname","text":"Returns an std::unordered_map<std::string, std::string> from a query string such as ?key[sub_key1]=value1&key[sub_key2]=value2&key[sub_key3]=value3 . The key in the map is what's in the brackets ( sub_key1 for example), and the value being what's after the = sign ( value1 ). The name passed to the function is not part of the returned value.","title":"get_dict(name)"},{"location":"guides/query-string/#pop_dictname","text":"Works the same as get_dict but removing the values from the query string. Warning if your query string contains both a list and dictionary with the same key, it is best to use pop_list before either get_dict or pop_dict , since a map cannot contain more than one value per key, each item in the list will override the previous and only the last will remain with an empty key. For more information take a look here .","title":"pop_dict(name)"},{"location":"guides/routes/","text":"Routes define what happens when your client connects to a certain URL. Macro CROW_ROUTE(app, url) Can be replaced with app . route < crow :: black_magick :: get_parameter_tag ( url ) > ( url ) or app . route_dynamic ( url ) if you're using VS2013 or want runtime url evaluation. Although this usage is NOT recommended. App Which app class to assign the route to. Path (URL) Which relative path is assigned to the route. Using /hello means the client will need to access http://example.com/hello in order to access the route. A path can have parameters, for example /hello/<int> will allow a client to input an int into the url which will be in the handler (something like http://example.com/hello/42 ). Parameters can be <int> , <uint> , <double> , <string> , or <path> . It's worth nothing that the parameters also need to be defined in the handler, an example of using parameters would be to add 2 numbers based on input: CROW_ROUTE ( app , \"/add/<int>/<int>\" ) ([]( int a , int b ) { return std :: to_string ( a + b ); }); you can see the first <int> is defined as a and the second as b . If you were to run this and call http://example.com/add/1/2 , the result would be a page with 3 . Exciting! Methods You can change the HTTP methods the route uses from just the default GET by using method() , your route macro should look like CROW_ROUTE(app, \"/add/<int>/<int>\").methods(crow::HTTPMethod::GET, crow::HTTPMethod::PATCH) or CROW_ROUTE(app, \"/add/<int>/<int>\").methods(\"GET\"_method, \"PATCH\"_method) . Note Crow handles HEAD and OPTIONS methods automatically. So adding those to your handler has no effect. Handler Basically a piece of code that gets executed whenever the client calls the associated route, usually in the form of a lambda expression . It can be as simple as ([](){ return \"Hello World\" }) . Request Handlers can also use information from the request by adding it as a parameter ([]( const crow :: request & req ){...}) . You can also access the url parameters in the handler using req . url_params . get ( \"param_name\" ); . If the parameter doesn't exist, nullptr is returned. For more information on crow::request go here . Response Crow also provides the ability to define a response in the parameters by using ([]( crow :: response & res ){...}) . Please note that in order to return a response defined as a parameter you'll need to use res.end(); . Alternatively, you can define the response in the body and return it ( ([](){ return crow :: response ()}) ). For more information on crow::response go here . Return statement A crow::response is very strictly tied to a route. If you can have something in a response constructor, you can return it in a handler. The main return type is std::string . although you could also return a crow::json::wvalue or crow::multipart::message directly. For more information on the specific constructors for a crow::response go here . Returning custom classes If you have your own class you want to return (without converting it to string and returning that), you can use the crow::returnable class. to use the returnable class, you only need your class to publicly extend crow::returnable , add a dump() method that returns your class as an std::string , and add a constructor that has a Content-Type header as a string argument. your class should look like the following: class a : public crow :: returnable { a () : returnable ( \"text/plain\" ){}; ... ... ... std :: string dump () override { return this . as_string (); } } Catchall routes By default, any request that Crow can't find a route for will return a simple 404 response. You can change that to return a default route using the CROW_CATCHALL_ROUTE(app) macro. Defining it is identical to a normal route, even when it comes to the const crow::request& and crow::response& parameters being optional.","title":"Routes"},{"location":"guides/routes/#macro","text":"CROW_ROUTE(app, url) Can be replaced with app . route < crow :: black_magick :: get_parameter_tag ( url ) > ( url ) or app . route_dynamic ( url ) if you're using VS2013 or want runtime url evaluation. Although this usage is NOT recommended.","title":"Macro"},{"location":"guides/routes/#app","text":"Which app class to assign the route to.","title":"App"},{"location":"guides/routes/#path-url","text":"Which relative path is assigned to the route. Using /hello means the client will need to access http://example.com/hello in order to access the route. A path can have parameters, for example /hello/<int> will allow a client to input an int into the url which will be in the handler (something like http://example.com/hello/42 ). Parameters can be <int> , <uint> , <double> , <string> , or <path> . It's worth nothing that the parameters also need to be defined in the handler, an example of using parameters would be to add 2 numbers based on input: CROW_ROUTE ( app , \"/add/<int>/<int>\" ) ([]( int a , int b ) { return std :: to_string ( a + b ); }); you can see the first <int> is defined as a and the second as b . If you were to run this and call http://example.com/add/1/2 , the result would be a page with 3 . Exciting!","title":"Path (URL)"},{"location":"guides/routes/#methods","text":"You can change the HTTP methods the route uses from just the default GET by using method() , your route macro should look like CROW_ROUTE(app, \"/add/<int>/<int>\").methods(crow::HTTPMethod::GET, crow::HTTPMethod::PATCH) or CROW_ROUTE(app, \"/add/<int>/<int>\").methods(\"GET\"_method, \"PATCH\"_method) . Note Crow handles HEAD and OPTIONS methods automatically. So adding those to your handler has no effect.","title":"Methods"},{"location":"guides/routes/#handler","text":"Basically a piece of code that gets executed whenever the client calls the associated route, usually in the form of a lambda expression . It can be as simple as ([](){ return \"Hello World\" }) .","title":"Handler"},{"location":"guides/routes/#request","text":"Handlers can also use information from the request by adding it as a parameter ([]( const crow :: request & req ){...}) . You can also access the url parameters in the handler using req . url_params . get ( \"param_name\" ); . If the parameter doesn't exist, nullptr is returned. For more information on crow::request go here .","title":"Request"},{"location":"guides/routes/#response","text":"Crow also provides the ability to define a response in the parameters by using ([]( crow :: response & res ){...}) . Please note that in order to return a response defined as a parameter you'll need to use res.end(); . Alternatively, you can define the response in the body and return it ( ([](){ return crow :: response ()}) ). For more information on crow::response go here .","title":"Response"},{"location":"guides/routes/#return-statement","text":"A crow::response is very strictly tied to a route. If you can have something in a response constructor, you can return it in a handler. The main return type is std::string . although you could also return a crow::json::wvalue or crow::multipart::message directly. For more information on the specific constructors for a crow::response go here .","title":"Return statement"},{"location":"guides/routes/#returning-custom-classes","text":"If you have your own class you want to return (without converting it to string and returning that), you can use the crow::returnable class. to use the returnable class, you only need your class to publicly extend crow::returnable , add a dump() method that returns your class as an std::string , and add a constructor that has a Content-Type header as a string argument. your class should look like the following: class a : public crow :: returnable { a () : returnable ( \"text/plain\" ){}; ... ... ... std :: string dump () override { return this . as_string (); } }","title":"Returning custom classes"},{"location":"guides/routes/#catchall-routes","text":"By default, any request that Crow can't find a route for will return a simple 404 response. You can change that to return a default route using the CROW_CATCHALL_ROUTE(app) macro. Defining it is identical to a normal route, even when it comes to the const crow::request& and crow::response& parameters being optional.","title":"Catchall routes"},{"location":"guides/ssl/","text":"Crow supports HTTPS though SSL or TLS. When mentioning SSL in this documentation, it is often a reference to openSSL, which includes TLS. Don't worry, we don't use obsolete security standards :) To enable SSL, first your application needs to define either a .crt and .key files, or a .pem file. Once you have your files, you can add them to your app like this: app . ssl_file ( \"/path/to/cert.crt\" , \"/path/to/keyfile.key\" ) or app . ssl_file ( \"/path/to/pem_file.pem\" ) . Please note that this method can be part of the app method chain, which means it can be followed by .run() or any other method. You can also set your own SSL context (by using boost::asio::ssl::context ctx ) and then applying it via the app . ssl ( ctx ) method. Warning If you plan on using a proxy like Nginx or Apache2, DO NOT use SSL in crow, instead define it in your proxy and keep the connection between the proxy and Crow non-SSL.","title":"SSL"},{"location":"guides/static/","text":"A static file is any file that resides in the server's storage. Crow supports returning Static files as responses in 2 ways. Implicit Crow implicitly returns any static files placed in a static directory and any subdirectories, as long as the user calls the endpoint /static/path/to/file . The static folder or endpoint can be changed by defining the macros CROW_STATIC_DIRECTORY \"alternative_directory/\" and CROW_STATIC_ENDPOINT \"/alternative_endpoint/<path>\" . static directory changes the directory in the server's filesystem, while the endpoint changes the URL that the client needs to access. Explicit You can directly return a static file by using the crow::response method response . set_static_file_info ( \"path/to/file\" ); . The path is relative to the executable unless preceded by / , then it is an absolute path. Please keep in mind that using the set_static_file_info method does invalidate any data already in your response body. Note : Crow sets the content-type header automatically based on the file's extension, if an extension is unavailable or undefined, Crow uses text/plain , if you'd like to explicitly set a content-type , use response . set_header ( \"content-type\" , \"mime/type\" ); AFTER calling set_static_file_info .","title":"Static Files"},{"location":"guides/static/#implicit","text":"Crow implicitly returns any static files placed in a static directory and any subdirectories, as long as the user calls the endpoint /static/path/to/file . The static folder or endpoint can be changed by defining the macros CROW_STATIC_DIRECTORY \"alternative_directory/\" and CROW_STATIC_ENDPOINT \"/alternative_endpoint/<path>\" . static directory changes the directory in the server's filesystem, while the endpoint changes the URL that the client needs to access.","title":"Implicit"},{"location":"guides/static/#explicit","text":"You can directly return a static file by using the crow::response method response . set_static_file_info ( \"path/to/file\" ); . The path is relative to the executable unless preceded by / , then it is an absolute path. Please keep in mind that using the set_static_file_info method does invalidate any data already in your response body. Note : Crow sets the content-type header automatically based on the file's extension, if an extension is unavailable or undefined, Crow uses text/plain , if you'd like to explicitly set a content-type , use response . set_header ( \"content-type\" , \"mime/type\" ); AFTER calling set_static_file_info .","title":"Explicit"},{"location":"guides/syste/","text":"Using Systemd allows you to run any executable or script when the system starts. This can be useful when you don't want to re-run your Crow application every single time you restart your server. Writing the Service Unit File In order to have Systemd recognize your application, you need to create a .service file that explains how Systemd should handle your program. To create a service file, you need to go to /etc/systemd/system and create an empty text file with the extension .service , the file name can be anything. Once the file is created, open it using your favorite text editor and add the following: [ Unit ] Description = My revolutionary Crow application Wants = network.target After = syslog.target network-online.target [ Service ] Type = simple ExecStart = /absolute/path/to/your/executable Restart = on-failure RestartSec = 10 KillMode = process [ Install ] WantedBy = multi-user.target You will then need to give the correct permission, this can be done by using the following command (a sudo maybe required): chmod 640 /etc/systemd/system/crowthing.service And that's it! You can now use your systemctl controls to enable , start , stop , or disable your Crow application. If you're not familiar with Systemd, systemctl enable crowthing.service will allow your Crow application to run at startup, start will start it, and the rest is simple.","title":"Systemd run on startup"},{"location":"guides/syste/#writing-the-service-unit-file","text":"In order to have Systemd recognize your application, you need to create a .service file that explains how Systemd should handle your program. To create a service file, you need to go to /etc/systemd/system and create an empty text file with the extension .service , the file name can be anything. Once the file is created, open it using your favorite text editor and add the following: [ Unit ] Description = My revolutionary Crow application Wants = network.target After = syslog.target network-online.target [ Service ] Type = simple ExecStart = /absolute/path/to/your/executable Restart = on-failure RestartSec = 10 KillMode = process [ Install ] WantedBy = multi-user.target You will then need to give the correct permission, this can be done by using the following command (a sudo maybe required): chmod 640 /etc/systemd/system/crowthing.service And that's it! You can now use your systemctl controls to enable , start , stop , or disable your Crow application. If you're not familiar with Systemd, systemctl enable crowthing.service will allow your Crow application to run at startup, start will start it, and the rest is simple.","title":"Writing the Service Unit File"},{"location":"guides/templating/","text":"Templating is when you return an html page with custom data. You can probably tell why that's useful. Crow supports mustache for templates through its own implementation crow::mustache . Components of mustache There are 2 components of a mustache template implementation: Page Context Page The HTML page (including the mustache tags). It is usually loaded into crow::mustache::template_t . It needs to be placed in the templates directory which should be directly inside the current working directory of the crow executable. For more information on how to formulate a template, see this mustache manual . Context A JSON object containing the tags as keys and their values. crow::mustache::context is actually a crow::json::wvalue . Returning a template To return a mustache template, you need to load a page using auto page = crow :: mustache :: load ( \"path/to/template.html\" ); , keep in mind that the path is relative to the templates directory. You also need to set up the context by using crow :: mustache :: context ctx ; . Then you need to assign the keys and values, this can be done the same way you assign values to a json write value ( ctx[\"key\"] = value; ). With your context and page ready, just return page . render ( ctx ); . This will use the context data to return a filled template. Alternatively you could just render the page without a context using return page . render (); .","title":"Templating (Mustache)"},{"location":"guides/templating/#components-of-mustache","text":"There are 2 components of a mustache template implementation: Page Context","title":"Components of mustache"},{"location":"guides/templating/#page","text":"The HTML page (including the mustache tags). It is usually loaded into crow::mustache::template_t . It needs to be placed in the templates directory which should be directly inside the current working directory of the crow executable. For more information on how to formulate a template, see this mustache manual .","title":"Page"},{"location":"guides/templating/#context","text":"A JSON object containing the tags as keys and their values. crow::mustache::context is actually a crow::json::wvalue .","title":"Context"},{"location":"guides/templating/#returning-a-template","text":"To return a mustache template, you need to load a page using auto page = crow :: mustache :: load ( \"path/to/template.html\" ); , keep in mind that the path is relative to the templates directory. You also need to set up the context by using crow :: mustache :: context ctx ; . Then you need to assign the keys and values, this can be done the same way you assign values to a json write value ( ctx[\"key\"] = value; ). With your context and page ready, just return page . render ( ctx ); . This will use the context data to return a filled template. Alternatively you could just render the page without a context using return page . render (); .","title":"Returning a template"},{"location":"guides/testing/","text":"Unit tests can be written in 2 ways for a Crow application. The handler method Crow Allows users to handle requests that may not come from the network. This is done by calling the handle(req, res) method and providing a request and response objects. Which causes crow to identify and run the appropriate handler, returning the resulting response. 1 2 3 4 5 6 7 8 9 10 11 12 13 CROW_ROUTE ( app , \"/place\" ) ([] { return \"hi\" ; }); app . validate (); //Used to make sure all the route handlers are in order. { request req ; response res ; req . url = \"/place\" ; app . handle ( req , res ); //res will contain a code of 200, and a response body of \"hi\" } Note This method is the simpler of the two and is usually all you really need to test your routes. Warning This method does not send any data, nor does it run any post handle code, so things like static file serving (as far as sending the actual data) or compression cannot be tested using this method. The client method This method involves creating a simple ASIO client that sends the request and receives the response. It is considerably more complex than the earlier method, but it is both more realistic and includes post handle operations. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 static char buf [ 2048 ]; SimpleApp app ; CROW_ROUTE ( app , \"/\" )([] { return \"A\" ; }); auto _ = async ( launch :: async ,[ & ] { app1 . bindaddr ( \"127.0.0.1\" ). port ( 45451 ). run (); }); app . wait_for_server_start (); std :: string sendmsg = \"GET / \\r\\n Content-Length:3 \\r\\n X-HeaderTest: 123 \\r\\n\\r\\n A=B \\r\\n \" ; asio :: io_service is ; { asio :: ip :: tcp :: socket c ( is ); c . connect ( asio :: ip :: tcp :: endpoint ( asio :: ip :: address :: from_string ( \"127.0.0.1\" ), 45451 )); c . send ( asio :: buffer ( sendmsg )); size_t recved = c . receive ( asio :: buffer ( buf , 2048 )); CHECK ( 'A' == buf [ recved - 1 ]); //This is specific to catch2 testing library, but it should give a general idea of how to read the response. } app . stop (); //THIS MUST RUN } The first part is straightforward, create an app and add a route. The second part is launching the app asynchronously and waiting until it starts. The third is formulating our HTTP request string, the format is: METHOD / Content-Length:123 header1:value1 header2:value2 BODY Next an io_service is created, then a TCP socket is created with the io_service and is connected to the application. Then send the HTTP request string through the socket inside a buffer, and read the result into the buffer in line 1 . Finally check the result against the expected one. Warning Be absolutely sure that the line app.stop() runs, whether the test fails or succeedes. Not running it WILL CAUSE OTHER TESTS TO FAIL AND THE TEST TO HANG UNTIL THE PROCESS IS TERMINATED.","title":"Writing Tests"},{"location":"guides/testing/#the-handler-method","text":"Crow Allows users to handle requests that may not come from the network. This is done by calling the handle(req, res) method and providing a request and response objects. Which causes crow to identify and run the appropriate handler, returning the resulting response. 1 2 3 4 5 6 7 8 9 10 11 12 13 CROW_ROUTE ( app , \"/place\" ) ([] { return \"hi\" ; }); app . validate (); //Used to make sure all the route handlers are in order. { request req ; response res ; req . url = \"/place\" ; app . handle ( req , res ); //res will contain a code of 200, and a response body of \"hi\" } Note This method is the simpler of the two and is usually all you really need to test your routes. Warning This method does not send any data, nor does it run any post handle code, so things like static file serving (as far as sending the actual data) or compression cannot be tested using this method.","title":"The handler method"},{"location":"guides/testing/#the-client-method","text":"This method involves creating a simple ASIO client that sends the request and receives the response. It is considerably more complex than the earlier method, but it is both more realistic and includes post handle operations. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 static char buf [ 2048 ]; SimpleApp app ; CROW_ROUTE ( app , \"/\" )([] { return \"A\" ; }); auto _ = async ( launch :: async ,[ & ] { app1 . bindaddr ( \"127.0.0.1\" ). port ( 45451 ). run (); }); app . wait_for_server_start (); std :: string sendmsg = \"GET / \\r\\n Content-Length:3 \\r\\n X-HeaderTest: 123 \\r\\n\\r\\n A=B \\r\\n \" ; asio :: io_service is ; { asio :: ip :: tcp :: socket c ( is ); c . connect ( asio :: ip :: tcp :: endpoint ( asio :: ip :: address :: from_string ( \"127.0.0.1\" ), 45451 )); c . send ( asio :: buffer ( sendmsg )); size_t recved = c . receive ( asio :: buffer ( buf , 2048 )); CHECK ( 'A' == buf [ recved - 1 ]); //This is specific to catch2 testing library, but it should give a general idea of how to read the response. } app . stop (); //THIS MUST RUN } The first part is straightforward, create an app and add a route. The second part is launching the app asynchronously and waiting until it starts. The third is formulating our HTTP request string, the format is: METHOD / Content-Length:123 header1:value1 header2:value2 BODY Next an io_service is created, then a TCP socket is created with the io_service and is connected to the application. Then send the HTTP request string through the socket inside a buffer, and read the result into the buffer in line 1 . Finally check the result against the expected one. Warning Be absolutely sure that the line app.stop() runs, whether the test fails or succeedes. Not running it WILL CAUSE OTHER TESTS TO FAIL AND THE TEST TO HANG UNTIL THE PROCESS IS TERMINATED.","title":"The client method"},{"location":"guides/websockets/","text":"Websockets are a way of connecting a client and a server without the request response nature of HTTP. To create a websocket in Crow, you need a websocket route. A websocket route differs from a normal route quite a bit. While it uses the same CROW_ROUTE(app, \"/url\") macro, that's about where the similarities end. A websocket route follows the macro with .websocket() which is then followed by a series of methods (with handlers inside) for each event. These are: onopen ([ & ]( crow :: websocket :: connection & conn ){ handler code goes here }) onaccept ([ & ]( const crow :: request & ){ handler code goes here }) (This handler has to return bool) onmessage ([ & ]( crow :: websocket :: connection & conn , const std :: string message , bool is_binary ){ handler code goes here }) onclose ([ & ]( crow :: websocket :: connection & conn , const std :: string reason ){ handler code goes here }) onerror ([ & ]( crow :: websocket :: connection & conn ){ handler code goes here }) These event methods and their handlers can be chained. The full Route should look similar to this: CROW_ROUTE ( app , \"/ws\" ) . websocket () . onopen ([ & ]( crow :: websocket :: connection & conn ){ do_something (); }) . onclose ([ & ]( crow :: websocket :: connection & conn , const std :: string & reason ){ do_something (); }) . onmessage ([ & ]( crow :: websocket :: connection & /*conn*/ , const std :: string & data , bool is_binary ){ if ( is_binary ) do_something ( data ); else do_something_else ( data ); }); For more info go here .","title":"Websockets"}]}